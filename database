# **FINAL DATABASE DESIGN**

---

## **ENTITY 1: STUDENT**

**Description**: A user who logs in and has conversations with AI clients

**Attributes:**
```
student_id          INTEGER         (Primary Key, Auto-increment)
email               VARCHAR(255)    (Unique, Not Null)
name                VARCHAR(255)    (Nullable)
created_at          TIMESTAMP       (Default: NOW())
last_login          TIMESTAMP       (Nullable)
```

**Keys:**
- **Primary Key**: `student_id`
- **Unique Constraint**: `email`

**Constraints:**
- `email` must be unique
- `email` cannot be NULL
- `student_id` auto-generates

---

## **ENTITY 2: SESSION**

**Description**: A conversation thread between a student and an AI client

**Attributes:**
```
session_id          UUID            (Primary Key)
student_id          INTEGER         (Foreign Key → students.student_id)
ai_client_type      VARCHAR(50)     (e.g., "Jitesh", "Professor Oak")
created_at          TIMESTAMP       (Default: NOW())
updated_at          TIMESTAMP       (Default: NOW(), Auto-update)
status              VARCHAR(20)     (Default: 'active', Check: 'active'|'closed')
```

**Keys:**
- **Primary Key**: `session_id`
- **Foreign Key**: `student_id` REFERENCES `students(student_id)`

**Constraints:**
- `student_id` must reference valid student (referential integrity)
- `status` must be either 'active' or 'closed'
- `session_id` is UUID (globally unique)
- ON DELETE CASCADE: If student deleted, delete all their sessions

---

## **ENTITY 3: MESSAGE**

**Description**: A single message (user or assistant) within a session

**Attributes:**
```
message_id          SERIAL          (Primary Key, Auto-increment)
session_id          UUID            (Foreign Key → sessions.session_id)
sender_type         VARCHAR(20)     (Not Null, Check: 'user'|'assistant')
content             TEXT            (Not Null)
sequence_number     INTEGER         (Not Null)
created_at          TIMESTAMP       (Default: NOW())
```

**Keys:**
- **Primary Key**: `message_id`
- **Foreign Key**: `session_id` REFERENCES `sessions(session_id)`
- **Composite Unique**: (`session_id`, `sequence_number`) - ensures no duplicate sequence in same session

**Constraints:**
- `session_id` must reference valid session (referential integrity)
- `sender_type` must be either 'user' or 'assistant'
- `content` cannot be NULL
- `sequence_number` must be positive
- ON DELETE CASCADE: If session deleted, delete all its messages

---

## **RELATIONSHIPS**

### **Relationship 1: STUDENT → SESSION**

```
Type: One-to-Many (1:M)

STUDENT (1) ──────has────── (∞) SESSION

- One student can have multiple sessions
- Each session belongs to exactly one student
```

**Implementation:**
- `sessions.student_id` is a Foreign Key pointing to `students.student_id`

**Cardinality:**
- Minimum: A student can have 0 sessions (just registered, haven't chatted)
- Maximum: A student can have unlimited sessions

---

### **Relationship 2: SESSION → MESSAGE**

```
Type: One-to-Many (1:M)

SESSION (1) ──────contains────── (∞) MESSAGE

- One session contains multiple messages
- Each message belongs to exactly one session
```

**Implementation:**
- `messages.session_id` is a Foreign Key pointing to `sessions.session_id`

**Cardinality:**
- Minimum: A session can have 0 messages (just created, no messages yet)
- Maximum: A session can have unlimited messages

---

### **Relationship 3: STUDENT → MESSAGE (Indirect)**

```
Type: One-to-Many (1:M) - through SESSION

STUDENT (1) ──→ SESSION (M) ──→ MESSAGE (∞)

- One student has multiple messages across all their sessions
- This is an indirect relationship (navigated through sessions)
```

**Implementation:**
- No direct foreign key needed
- Accessed by: `student → sessions → messages`

---

## **COMPLETE SCHEMA DIAGRAM**

```
┌─────────────────────────────┐
│        STUDENTS             │
├─────────────────────────────┤
│ 🔑 student_id (PK)          │
│ ⚡ email (UNIQUE)           │
│    name                     │
│    created_at               │
│    last_login               │
└─────────────────────────────┘
          │
          │ 1:M
          │ (one student, many sessions)
          ▼
┌─────────────────────────────┐
│        SESSIONS             │
├─────────────────────────────┤
│ 🔑 session_id (PK)          │
│ 🔗 student_id (FK)          │
│    ai_client_type           │
│    created_at               │
│    updated_at               │
│    status                   │
└─────────────────────────────┘
          │
          │ 1:M
          │ (one session, many messages)
          ▼
┌─────────────────────────────┐
│        MESSAGES             │
├─────────────────────────────┤
│ 🔑 message_id (PK)          │
│ 🔗 session_id (FK)          │
│    sender_type              │
│    content                  │
│    sequence_number          │
│    created_at               │
└─────────────────────────────┘

Legend:
🔑 = Primary Key
🔗 = Foreign Key
⚡ = Unique Constraint
```

---

## **ALL KEYS SUMMARY**

### **Primary Keys:**
```
students.student_id     → Uniquely identifies each student
sessions.session_id     → Uniquely identifies each conversation
messages.message_id     → Uniquely identifies each message
```

### **Foreign Keys:**
```
sessions.student_id     → References students.student_id
messages.session_id     → References sessions.session_id
```

### **Unique Constraints:**
```
students.email                              → No duplicate emails
(messages.session_id, sequence_number)      → No duplicate sequence in same session
```

---

## **ALL CONSTRAINTS SUMMARY**

### **Entity Integrity:**
- All tables have a primary key
- Primary keys cannot be NULL
- Primary keys are unique

### **Referential Integrity:**
```sql
sessions.student_id → students.student_id
  ON DELETE CASCADE
  ON UPDATE CASCADE
  
messages.session_id → sessions.session_id
  ON DELETE CASCADE
  ON UPDATE CASCADE
```

### **Domain Constraints:**
```sql
students.email          NOT NULL, UNIQUE
sessions.status         CHECK (status IN ('active', 'closed'))
messages.sender_type    CHECK (sender_type IN ('user', 'assistant'))
messages.content        NOT NULL
messages.sequence_number > 0
```

### **Business Rules:**
- A message must have valid session_id
- A session must have valid student_id
- Sequence numbers must be unique within a session
- Email addresses must be unique across all students

---

## **SAMPLE DATA FLOW**

### **Creating a new conversation:**
```
1. Student "jai@gmail.com" logs in
   → Find student_id = 1 from STUDENTS table

2. Student clicks "New Chat with Jitesh"
   → Generate new UUID: session_id = "aaa1-1111..."
   → INSERT INTO sessions (session_id, student_id, ai_client_type)
   → VALUES ("aaa1-1111...", 1, "Jitesh")

3. Student sends "Hello"
   → INSERT INTO messages (session_id, sender_type, content, sequence_number)
   → VALUES ("aaa1-1111...", "user", "Hello", 1)

4. AI replies "Hi Jai!"
   → INSERT INTO messages (session_id, sender_type, content, sequence_number)
   → VALUES ("aaa1-1111...", "assistant", "Hi Jai!", 2)
```

---

## **CARDINALITY SUMMARY**

| Relationship | Type | Min | Max | Notes |
|--------------|------|-----|-----|-------|
| Student → Session | 1:M | 0 | ∞ | Student can have no sessions or many |
| Session → Message | 1:M | 0 | ∞ | Session can be empty or have many messages |
| Student → Message | 1:M (indirect) | 0 | ∞ | Through sessions |

---

## **DATA TYPES RATIONALE**

| Attribute | Data Type | Why? |
|-----------|-----------|------|
| `student_id` | SERIAL/INTEGER | Auto-incrementing number, efficient for joins |
| `email` | VARCHAR(255) | Standard email length, indexed for fast lookup |
| `session_id` | UUID | Globally unique, can be generated client-side |
| `ai_client_type` | VARCHAR(50) | Short string, could be enum in production |
| `sender_type` | VARCHAR(20) | Could be enum: 'user' or 'assistant' |
| `content` | TEXT | Unlimited length for long messages |
| `sequence_number` | INTEGER | Order within conversation |
| Timestamps | TIMESTAMP | Date and time with timezone support |

---

This is your **complete, production-ready database design** for the chat system! 🎯
